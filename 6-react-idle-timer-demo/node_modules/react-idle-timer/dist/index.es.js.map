{"version":3,"file":"index.es.js","sources":["../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js","../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../node_modules/regenerator-runtime/runtime.js","../src/utils.js","../src/MessageChannel/methods/broadcastChannel.js","../src/MessageChannel/ObliviousSet.js","../src/MessageChannel/methods/localStorage.js","../src/MessageChannel/methods/simulate.js","../src/MessageChannel/methodChooser.js","../src/MessageChannel/MessageChannel.js","../src/MessageChannel/leaderElection.js","../src/TabManager.js","../src/IdleTimer.js","../node_modules/@babel/runtime/helpers/esm/inherits.js","../src/useIdleTimer.js"],"sourcesContent":["export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}","import _typeof from \"@babel/runtime/helpers/typeof\";\nimport assertThisInitialized from \"./assertThisInitialized.js\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nexport default function _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","/**\n * Determine if we are in a browser\n * or a server environment\n * @type {Boolean}\n * @private\n */\nexport const IS_BROWSER =\n  (typeof window === 'undefined' ? 'undefined' : typeof window) === 'object'\n\n/**\n * Default element to listen for events on\n * @type {Object}\n * @private\n */\nexport const DEFAULT_ELEMENT = IS_BROWSER ? document : {}\n\n/**\n * The default events to determine activity\n * @type {Array}\n * @private\n */\nexport const DEFAULT_EVENTS = [\n  'mousemove',\n  'keydown',\n  'wheel',\n  'DOMMouseScroll',\n  'mousewheel',\n  'mousedown',\n  'touchstart',\n  'touchmove',\n  'MSPointerDown',\n  'MSPointerMove',\n  'visibilitychange'\n]\n\n/**\n * Creates a debounced function that delays invoking func until\n * after delay milliseconds has elapsed since the last time the\n * debounced function was invoked.\n * @name debounced\n * @param  {Function} fn   Function to debounce\n * @param  {Number} delay  How long to wait\n * @return {Function}      Executed Function\n * @private\n **/\nexport function debounced (fn, delay) {\n  let timerId\n  function result (...args) {\n    if (timerId) {\n      clearTimeout(timerId)\n    }\n    timerId = setTimeout(() => {\n      fn(...args)\n      timerId = null\n    }, delay)\n  }\n\n  result.cancel = function () {\n    clearTimeout(timerId)\n  }\n\n  return result\n}\n\n/**\n * Creates a throttled function that only invokes func at most\n * once per every wait milliseconds.\n * @name throttled\n * @param  {Function} fn   Function to debounce\n * @param  {Number} delay  How long to wait\n * @return {Function}      Executed Function\n * @private\n **/\nexport function throttled (fn, delay) {\n  let lastCall = 0\n  return function (...args) {\n    const now = new Date().getTime()\n    if (now - lastCall < delay) {\n      return\n    }\n    lastCall = now\n    return fn(...args)\n  }\n}\n\nlet lastMs = 0\nlet additional = 0\n\n/**\n * Returns current time in microseconds.\n *\n * @returns {Number} current time in microseconds\n * @private\n */\nexport function microSeconds () {\n  const ms = new Date().getTime()\n  if (ms === lastMs) {\n    additional++\n    return ms * 1000 + additional\n  } else {\n    lastMs = ms\n    additional = 0\n    return ms * 1000\n  }\n}\n\n/**\n * Generate and return a random token.\n *\n * @returns {String} Random token.\n * @private\n */\nexport function randomToken () {\n  return Math.random().toString(36).substring(2)\n}\n\n/**\n * Checks if a js object is a promise.\n *\n * @param {*} obj  Any javascript object.\n * @returns {Boolean} Wether or not this object is a promise.\n */\nexport function isPromise (obj) {\n  if (obj && typeof obj.then === 'function') {\n    /* istanbul ignore next */\n    return true\n  } else {\n    return false\n  }\n}\n\n/**\n * Sleeps for x amount of milliseconds.\n *\n * @param {Number} time   Amount of time in milliseconds.\n * @returns {Promise}\n * @private\n */\nexport function sleep (time = 0) {\n  return new Promise(resolve => setTimeout(resolve, time))\n}\n\n/**\n * Get the current timestamp.\n *\n * @returns {Number}\n * @private\n */\nexport function now () {\n  return new Date().getTime()\n}\n\n/**\n * Waits until the given function returns true\n * @param  {function}  fn\n * @return {Promise}\n */\nexport function waitUntil (fn, timeout = 0, interval = 20) {\n  let timedOut = false\n  let ok = false\n\n  /* istanbul ignore next */\n  if (timeout !== 0) {\n    sleep(timeout).then(() => {\n      timedOut = true\n    })\n  }\n\n  return new Promise((resolve, reject) => {\n    const runLoop = () => {\n      if (ok) {\n        resolve()\n        return\n      }\n      /* istanbul ignore next */\n      if (timedOut) {\n        reject(new Error(`❌ waitUntil reached timeout of ${timeout}ms`))\n        return\n      }\n      sleep(interval).then(() => {\n        ok = fn()\n        runLoop()\n      })\n    }\n    runLoop()\n  })\n}\n","/* eslint-env browser */\nimport { microSeconds } from '../../utils'\n\nexport const type = 'broadcastChannel'\n\nexport function create (channelName) {\n  const state = {\n    messagesCallback: null,\n    bc: new BroadcastChannel(channelName)\n  }\n\n  state.bc.onmessage = msg => {\n    if (state.messagesCallback) {\n      state.messagesCallback(msg.data)\n    }\n  }\n\n  return state\n}\n\nexport function close (channelState) {\n  channelState.bc.close()\n}\n\nexport function postMessage (channelState, messageJson) {\n  try {\n    channelState.bc.postMessage(messageJson, false)\n    return Promise.resolve()\n  } catch (err) {\n    /* istanbul ignore next */\n    return Promise.reject(err)\n  }\n}\n\nexport function onMessage (channelState, fn) {\n  channelState.messagesCallback = fn\n}\n\nexport function canBeUsed () {\n  if (typeof BroadcastChannel === 'function') {\n    return true\n  } else {\n    /* istanbul ignore next */\n    return false\n  }\n}\n\nexport function averageResponseTime () {\n  return 150\n}\n\nexport default {\n  create,\n  close,\n  onMessage,\n  postMessage,\n  canBeUsed,\n  type,\n  averageResponseTime,\n  microSeconds\n}\n","import { now } from '../utils'\n\nexport default class ObliviousSet {\n  constructor (ttl = 1000 * 60) {\n    this.ttl = ttl\n    this.set = new Set()\n    this.timeMap = new Map()\n  }\n\n  has (value) {\n    return this.set.has(value)\n  }\n\n  add (value) {\n    this.timeMap.set(value, now())\n    this.set.add(value)\n    this._removeTooOldValues()\n  }\n\n  clear () {\n    this.set.clear()\n    this.timeMap.clear()\n  }\n\n  _removeTooOldValues () {\n    const olderThen = now() - this.ttl\n    const iterator = this.set[Symbol.iterator]()\n\n    while (true) {\n      const value = iterator.next().value\n      if (!value) return // no more elements\n      const time = this.timeMap.get(value)\n      if (time < olderThen) {\n        this.timeMap.delete(value)\n        this.set.delete(value)\n      } else {\n        // We reached a value that is not old enough\n        return\n      }\n    }\n  }\n}\n","import ObliviousSet from '../ObliviousSet'\n\nimport {\n  randomToken,\n  microSeconds\n} from '../../utils'\n\nexport const type = 'localStorage'\n\n/**\n * Returns local storage instance\n */\nexport function getLocalStorage () {\n  let localStorage\n  if (typeof window === 'undefined') return null\n  try {\n    localStorage = window.localStorage\n    localStorage = window['ie8-eventlistener/storage'] || window.localStorage\n  } catch (e) {\n    // New versions of Firefox throw a Security exception\n    // if cookies are disabled. See\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1028153\n  }\n  return localStorage\n}\n\nexport function storageKey (channelName) {\n  return channelName\n}\n\n/**\n* writes the new message to the storage\n* and fires the storage-event so other readers can find it\n*/\nexport function postMessage (channelState, messageJson) {\n  return new Promise(resolve => {\n    const key = storageKey(channelState.channelName)\n    const writeObj = {\n      token: randomToken(),\n      time: new Date().getTime(),\n      data: messageJson,\n      uuid: channelState.uuid\n    }\n    const value = JSON.stringify(writeObj)\n    getLocalStorage().setItem(key, value)\n\n    /**\n       * StorageEvent does not fire the 'storage' event\n       * in the window that changes the state of the local storage.\n       * So we fire it manually\n       */\n    const ev = document.createEvent('Event')\n    ev.initEvent('storage', true, true)\n    ev.key = key\n    ev.newValue = value\n    window.dispatchEvent(ev)\n\n    resolve()\n  })\n}\n\nexport function addStorageEventListener (channelName, fn) {\n  const key = storageKey(channelName)\n  const listener = ev => {\n    if (ev.key === key) {\n      fn(JSON.parse(ev.newValue))\n    }\n  }\n  window.addEventListener('storage', listener)\n  return listener\n}\nexport function removeStorageEventListener (listener) {\n  window.removeEventListener('storage', listener)\n}\n\nexport function create (channelName, options = {}) {\n  if (!canBeUsed()) {\n    /* istanbul ignore next */\n    throw new Error('❌ localStorage cannot be used.')\n  }\n\n  const uuid = randomToken()\n\n  /**\n     * eMIs\n     * contains all messages that have been emitted before\n     * @type {ObliviousSet}\n     */\n  const eMIs = new ObliviousSet(options.removeTimeout)\n\n  const state = {\n    channelName,\n    uuid,\n    eMIs // emittedMessagesIds\n  }\n\n  state.listener = addStorageEventListener(\n    channelName,\n    (msgObj) => {\n      if (!state.messagesCallback) return // no listener\n      if (msgObj.uuid === uuid) return // own message\n      if (!msgObj.token || eMIs.has(msgObj.token)) return // already emitted\n      if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return // too old\n\n      eMIs.add(msgObj.token)\n      state.messagesCallback(msgObj.data)\n    }\n  )\n\n  return state\n}\n\nexport function close (channelState) {\n  removeStorageEventListener(channelState.listener)\n}\n\nexport function onMessage (channelState, fn, time) {\n  channelState.messagesCallbackTime = time\n  channelState.messagesCallback = fn\n}\n\nexport function canBeUsed () {\n  const ls = getLocalStorage()\n\n  if (!ls) return false\n\n  try {\n    const key = '__check'\n    ls.setItem(key, 'works')\n    ls.removeItem(key)\n  } catch (e) {\n    // Safari 10 in private mode will not allow write access to local\n    // storage and fail with a QuotaExceededError. See\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API#Private_Browsing_Incognito_modes\n\n    /* istanbul ignore next */\n    return false\n  }\n\n  return true\n}\n\n/* istanbul ignore next */\nexport function averageResponseTime () {\n  const defaultTime = 120\n  const userAgent = navigator.userAgent.toLowerCase()\n  if (userAgent.includes('safari') && !userAgent.includes('chrome')) {\n    // safari is much slower so this time is higher\n    return defaultTime * 2\n  }\n  return defaultTime\n}\n\nexport default {\n  create,\n  close,\n  onMessage,\n  postMessage,\n  canBeUsed,\n  type,\n  averageResponseTime,\n  microSeconds\n}\n","import { microSeconds } from '../../utils'\n\nexport const type = 'simulate'\n\nconst SIMULATE_CHANNELS = new Set()\n\nexport function create (channelName) {\n  const state = {\n    name: channelName,\n    messagesCallback: null\n  }\n  SIMULATE_CHANNELS.add(state)\n\n  return state\n}\n\nexport function close (channelState) {\n  SIMULATE_CHANNELS.delete(channelState)\n}\n\nexport function postMessage (channelState, messageJson) {\n  return new Promise(resolve => setTimeout(() => {\n    const channelArray = Array.from(SIMULATE_CHANNELS)\n    channelArray\n      .filter(channel => channel.name === channelState.name)\n      .filter(channel => channel !== channelState)\n      .filter(channel => !!channel.messagesCallback)\n      .forEach(channel => channel.messagesCallback(messageJson))\n    resolve()\n  }, 5))\n}\n\nexport function onMessage (channelState, fn) {\n  channelState.messagesCallback = fn\n}\n\n/* istanbul ignore next */\nexport function canBeUsed () {\n  return true\n}\n\n/* istanbul ignore next */\nexport function averageResponseTime () {\n  return 5\n}\n\nexport default {\n  create,\n  close,\n  onMessage,\n  postMessage,\n  canBeUsed,\n  type,\n  averageResponseTime,\n  microSeconds\n}\n","import BroadcastChannelMethod from './methods/broadcastChannel'\nimport LocalStorageMethod from './methods/localStorage'\nimport SimulateMethod from './methods/simulate'\n\n// Order is important\nconst METHODS = [\n  BroadcastChannelMethod,\n  LocalStorageMethod\n]\n\nexport function chooseMethod (options = {}) {\n  if (options.type) {\n    // For testing\n    if (options.type === 'simulate') {\n      return SimulateMethod\n    }\n\n    // Chosen type\n    const method = METHODS.find(m => m.type === options.type)\n    if (!method) throw new Error(`❌ Method ${options.type} is not supported.`)\n    else return method\n  }\n\n  const useMethod = METHODS.find(method => method.canBeUsed())\n\n  /* istanbul ignore next */\n  if (!useMethod) {\n    throw new Error(`❌ No method found ${JSON.stringify(METHODS.map(m => m.type))}`)\n  }\n  return useMethod\n}\n","import { chooseMethod } from './methodChooser'\nimport { isPromise } from '../utils'\n\nexport class MessageChannel {\n  constructor (name, options = {}) {\n    this.name = name\n    this.options = options\n    this.method = chooseMethod(this.options)\n    this.closed = false\n\n    // isListening\n    this._isListening = false\n\n    /**\n     * _onMessageListener\n     * setting onmessage twice,\n     * will overwrite the first listener\n     */\n    this._onMessageListener = null\n\n    /**\n     * _addEventListeners\n     */\n    this._addEventListeners = {\n      message: [],\n      internal: []\n    }\n\n    /**\n     * Un send message promises\n     * where the sending is still in progress\n     * @type {Set<Promise>}\n     */\n    this._unSendMessagePromises = new Set()\n\n    /**\n     * _beforeClose\n     * array of promises that will be awaited\n     * before the channel is closed\n     */\n    this._beforeClose = []\n\n    /**\n     * _preparePromise\n     */\n    this._preparePromises = null\n    _prepareChannel(this)\n  }\n\n  postMessage (msg) {\n    if (this.closed) {\n      throw new Error(\n        '❌ Cannot post message after channel has closed'\n      )\n    }\n    return _post(this, 'message', msg)\n  }\n\n  postInternal (msg) {\n    return _post(this, 'internal', msg)\n  }\n\n  set onmessage (fn) {\n    const time = this.method.microSeconds()\n    const listenObj = {\n      time,\n      fn\n    }\n    _removeListenerObject(this, 'message', this._onMessageListener)\n    if (fn && typeof fn === 'function') {\n      this._onMessageListener = listenObj\n      _addListenerObject(this, 'message', listenObj)\n    } else {\n      /* istanbul ignore next */\n      this._onMessageListener = null\n    }\n  }\n\n  /* istanbul ignore next */\n  get onmessage () {\n    return this._onMessageListener\n  }\n\n  addEventListener (type, fn) {\n    const time = this.method.microSeconds()\n    const listenObj = {\n      time,\n      fn\n    }\n    _addListenerObject(this, type, listenObj)\n  }\n\n  removeEventListener (type, fn) {\n    const obj = this._addEventListeners[type].find(obj => obj.fn === fn)\n    _removeListenerObject(this, type, obj)\n  }\n\n  close () {\n    if (this.closed) {\n      return\n    }\n    this.closed = true\n    const awaitPrepare = this._preparePromises ? this._preparePromises : Promise.resolve()\n\n    this._onMessageListener = null\n    this._addEventListeners.message = []\n\n    return awaitPrepare\n      // Wait until all current sending are processed\n      .then(() => Promise.all(Array.from(this._unSendMessagePromises)))\n      // Run before-close hooks\n      .then(() => Promise.all(this._beforeClose.map(fn => fn())))\n      // Close the channel\n      .then(() => this.method.close(this._state))\n  }\n\n  get type () {\n    return this.method.type\n  }\n\n  isClosed () {\n    return this.closed\n  }\n}\n\nfunction _post (messageChannel, type, msg) {\n  const time = messageChannel.method.microSeconds()\n  const msgObj = {\n    time,\n    type,\n    data: msg\n  }\n\n  const awaitPrepare = messageChannel._preparePromises ? messageChannel._preparePromises : Promise.resolve()\n  return awaitPrepare.then(() => {\n    const sendPromise = messageChannel.method.postMessage(\n      messageChannel._state,\n      msgObj\n    )\n\n    // add/remove to un-send messages list\n    messageChannel._unSendMessagePromises.add(sendPromise)\n    sendPromise\n      .catch()\n      .then(() => messageChannel._unSendMessagePromises.delete(sendPromise))\n\n    return sendPromise\n  })\n}\n\nfunction _prepareChannel (channel) {\n  const maybePromise = channel.method.create(channel.name, channel.options)\n  /* istanbul ignore next */\n  if (isPromise(maybePromise)) {\n    channel._preparePromises = maybePromise\n    maybePromise.then(s => {\n      channel._state = s\n    })\n  } else {\n    channel._state = maybePromise\n  }\n}\n\nfunction _hasMessageListeners (channel) {\n  if (channel._addEventListeners.message.length > 0) return true\n  if (channel._addEventListeners.internal.length > 0) return true\n  return false\n}\n\nfunction _addListenerObject (channel, type, obj) {\n  channel._addEventListeners[type].push(obj)\n  _startListening(channel)\n}\n\nfunction _removeListenerObject (channel, type, obj) {\n  channel._addEventListeners[type] = channel._addEventListeners[type].filter(o => o !== obj)\n  _stopListening(channel)\n}\n\nfunction _startListening (channel) {\n  if (!channel._isListening && _hasMessageListeners(channel)) {\n    // someone is listening, start subscribing\n\n    const listenerFn = msgObj => {\n      channel._addEventListeners[msgObj.type].forEach(obj => {\n        if (msgObj.time >= obj.time) {\n          obj.fn(msgObj.data)\n        }\n      })\n    }\n\n    const time = channel.method.microSeconds()\n    if (channel._preparePromises) {\n      /* istanbul ignore next */\n      channel._preparePromises.then(() => {\n        channel._isListening = true\n        channel.method.onMessage(\n          channel._state,\n          listenerFn,\n          time\n        )\n      })\n    } else {\n      channel._isListening = true\n      channel.method.onMessage(\n        channel._state,\n        listenerFn,\n        time\n      )\n    }\n  }\n}\n\nfunction _stopListening (channel) {\n  if (channel._isListening && !_hasMessageListeners(channel)) {\n    // no one is listening, stop subscribing\n    channel._isListening = false\n    const time = channel.method.microSeconds()\n    channel.method.onMessage(\n      channel._state,\n      null,\n      time\n    )\n  }\n}\n","import { IS_BROWSER, sleep, randomToken } from '../utils'\n\nclass LeaderElection {\n  constructor (channel, options) {\n    this._channel = channel\n    this._options = options\n\n    this.isLeader = false\n    this.isDead = false\n    this.token = randomToken()\n\n    this._isApplying = false\n    this._reApply = false\n\n    // things to clean up\n    this._unloadFns = []\n    this._listeners = []\n    this._intervals = []\n    this._duplicateListeners = () => { }\n    this._duplicateCalled = false\n    this._onBeforeDie = async () => {}\n\n    const unloadFn = async () => this.die()\n\n    if (IS_BROWSER) {\n      window.addEventListener('beforeUnload', unloadFn)\n      window.addEventListener('unload', unloadFn)\n\n      this._unloadFns.push(['beforeUnload', unloadFn])\n      this._unloadFns.push(['unload', unloadFn])\n    }\n  }\n\n  applyOnce () {\n    if (this.isLeader) return Promise.resolve(false)\n    if (this.isDead) return Promise.resolve(false)\n\n    // do nothing if already running\n    if (this._isApplying) {\n      this._reApply = true\n      return Promise.resolve(false)\n    }\n    this._isApplying = true\n\n    let stopCriteria = false\n    const received = []\n\n    const handleMessage = (msg) => {\n      if (msg.context === 'leader' && msg.token !== this.token) {\n        received.push(msg)\n\n        if (msg.action === 'apply') {\n          // Other is applying\n          if (msg.token > this.token) {\n            // Other has higher token, stop applying\n            stopCriteria = true\n          }\n        }\n\n        if (msg.action === 'tell') {\n          // Other is already leader\n          stopCriteria = true\n        }\n      }\n    }\n    this._channel.addEventListener('internal', handleMessage)\n\n    return _sendMessage(this, 'apply') // send out that this one is applying\n      .then(() => sleep(this._options.responseTime)) // let others time to respond\n      .then(() => {\n        if (stopCriteria) return Promise.reject(new Error())\n        else return _sendMessage(this, 'apply')\n      })\n      .then(() => sleep(this._options.responseTime)) // let others time to respond\n      .then(() => {\n        if (stopCriteria) return Promise.reject(new Error())\n        else return _sendMessage(this)\n      })\n      .then(() => beLeader(this)) // no one disagreed -> this one is now leader\n      .then(() => true)\n      .catch(() => false) // apply not successful\n      .then(success => {\n        this._channel.removeEventListener('internal', handleMessage)\n        this._isApplying = false\n        if (!success && this._reApply) {\n          this._reApply = false\n          return this.applyOnce()\n        } else return success\n      })\n  }\n\n  awaitLeadership () {\n    if (\n      !this._awaitLeadershipPromise\n    ) {\n      this._awaitLeadershipPromise = _awaitLeadershipOnce(this)\n    }\n    return this._awaitLeadershipPromise\n  }\n\n  set onDuplicate (fn) {\n    this._duplicateListeners = fn\n  }\n\n  /* istanbul ignore next */\n  get onDuplicate () {\n    return this._duplicateListeners\n  }\n\n  set onBeforeDie (fn) {\n    this._onBeforeDie = fn\n  }\n\n  /* istanbul ignore next */\n  get onBeforeDie () {\n    return this._onBeforeDie\n  }\n\n  async die () {\n    if (this.isDead) return\n    this.isDead = true\n\n    await this.onBeforeDie()\n    this._listeners.forEach(listener => this._channel.removeEventListener('internal', listener))\n    this._intervals.forEach(interval => clearInterval(interval))\n    this._unloadFns.forEach(uFn => {\n      if (IS_BROWSER) {\n        window.removeEventListener(uFn[0], uFn[1])\n      }\n    })\n    return _sendMessage(this, 'death')\n  }\n}\n\nfunction _awaitLeadershipOnce (leaderElector) {\n  if (leaderElector.isLeader) return Promise.resolve()\n\n  return new Promise(resolve => {\n    let resolved = false\n\n    function finish () {\n      /* istanbul ignore next */\n      if (resolved) {\n        return\n      }\n      resolved = true\n      clearInterval(interval)\n      leaderElector._channel.removeEventListener('internal', whenDeathListener)\n      resolve(true)\n    }\n\n    // try once now\n    leaderElector.applyOnce().then(() => {\n      if (leaderElector.isLeader) {\n        finish()\n      }\n    })\n\n    // try on fallbackInterval\n    const interval = setInterval(() => {\n      /* istanbul ignore next */\n      leaderElector.applyOnce().then(() => {\n        if (leaderElector.isLeader) {\n          finish()\n        }\n      })\n    }, leaderElector._options.fallbackInterval)\n    leaderElector._intervals.push(interval)\n\n    // try when other leader dies\n    const whenDeathListener = msg => {\n      if (msg.context === 'leader' && msg.action === 'death') {\n        leaderElector.applyOnce().then(() => {\n          if (leaderElector.isLeader) finish()\n        })\n      }\n    }\n    leaderElector._channel.addEventListener('internal', whenDeathListener)\n    leaderElector._listeners.push(whenDeathListener)\n  })\n}\n\n/**\n * Sends and internal message over the broadcast-channel\n */\nfunction _sendMessage (leaderElector, action) {\n  const msgJson = {\n    context: 'leader',\n    action,\n    token: leaderElector.token\n  }\n  return leaderElector._channel.postInternal(msgJson)\n}\n\nexport function beLeader (leaderElector) {\n  leaderElector.isLeader = true\n\n  const isLeaderListener = msg => {\n    if (msg.context === 'leader' && msg.action === 'apply') {\n      _sendMessage(leaderElector, 'tell')\n    }\n\n    if (msg.context === 'leader' && msg.action === 'tell' && !leaderElector._duplicateCalled) {\n      /**\n       * Another instance is also leader!\n       * This can happen on rare events\n       * like when the CPU is at 100% for long time\n       * or the tabs are open very long and the browser throttles them.\n       */\n      leaderElector._duplicateCalled = true\n      leaderElector._duplicateListeners() // message the lib user so the app can handle the problem\n      _sendMessage(leaderElector, 'tell') // ensure other leader also knows the problem\n    }\n  }\n  leaderElector._channel.addEventListener('internal', isLeaderListener)\n  leaderElector._listeners.push(isLeaderListener)\n  return _sendMessage(leaderElector, 'tell')\n}\n\nexport function createLeaderElection (channel, options) {\n  if (channel._leaderElector) {\n    throw new Error('❌ MessageChannel already has a leader-elector')\n  }\n\n  const elector = new LeaderElection(channel, options)\n  channel._beforeClose.push(async () => elector.die())\n\n  channel._leaderElector = elector\n  return elector\n}\n","import { MessageChannel, createLeaderElection } from './MessageChannel'\nexport const TabManager = ({\n  type,\n  channelName,\n  fallbackInterval,\n  responseTime,\n  emitOnAllTabs,\n  onIdle,\n  onActive,\n  start,\n  reset,\n  pause,\n  resume\n}) => {\n  const channel = new MessageChannel(channelName, { type })\n  const elector = createLeaderElection(channel, { fallbackInterval, responseTime })\n  const registry = {}\n\n  // Register self\n  registry[elector.token] = false\n\n  let leader = false\n  let allIdle = true\n\n  const isLeader = () => leader\n\n  elector.awaitLeadership().then(() => {\n    leader = true\n  })\n\n  channel.addEventListener('message', ([type, id]) => {\n    switch (type) {\n      case 'register':\n        registry[id] = false\n        break\n      case 'deregister':\n        delete registry[id]\n        break\n      case 'idle':\n        idle(id)\n        break\n      case 'active':\n        active(id)\n        break\n      case 'emitIdle':\n        onIdle()\n        break\n      case 'emitActive':\n        onActive()\n        break\n      case 'start':\n        start(true)\n        break\n      case 'reset':\n        reset(true)\n        break\n      case 'pause':\n        pause(true)\n        break\n      case 'resume':\n        resume(true)\n        break\n      default:\n        // no op\n    }\n  })\n\n  const setAllIdle = bool => {\n    allIdle = bool\n  }\n\n  const isAllIdle = () => allIdle\n\n  const idle = (id = elector.token) => {\n    registry[id] = true\n    const isIdle = Object.values(registry).every(v => v)\n    if (!allIdle && isIdle) {\n      allIdle = true\n      if (isLeader()) {\n        onIdle()\n        if (emitOnAllTabs) send('emitIdle')\n      } else {\n        send('idle')\n      }\n    }\n  }\n\n  const active = (id = elector.token) => {\n    registry[id] = false\n    const isActive = Object.values(registry).some(v => !v)\n    if (allIdle && isActive) {\n      allIdle = false\n      if (isLeader()) {\n        onActive()\n        if (emitOnAllTabs) send('emitActive')\n      } else {\n        send('active')\n      }\n    }\n  }\n\n  /* istanbul ignore next */\n  elector.onDuplicate = async () => await elector.die()\n  elector.onBeforeDie = async () => await send('deregister')\n\n  const send = async message => channel.postMessage([message, elector.token])\n\n  const close = async () => {\n    await elector.die()\n    await channel.close()\n  }\n\n  // Register self with remote tabs\n  send('register')\n\n  return { close, send, isLeader, idle, active, isAllIdle, setAllIdle }\n}\n","/**\n *  ___    _ _     _____ _\n * |_ _|__| | | __|_   _(_)_ __ ___   ___ _ __\n *  | |/ _` | |/ _ \\| | | | '_ ` _ \\ / _ \\ '__|\n *  | | (_| | |  __/| | | | | | | | |  __/ |\n * |___\\__,_|_|\\___||_| |_|_| |_| |_|\\___|_|\n *\n * @name IdleTimer\n * @author Randy Lebeau\n * @private\n */\n\nimport { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport { TabManager } from './TabManager'\nimport { IS_BROWSER, DEFAULT_ELEMENT, DEFAULT_EVENTS, debounced, throttled } from './utils'\n\n/**\n * Detects when your user is idle\n * @class IdleTimer\n * @private\n */\nclass IdleTimer extends Component {\n  /**\n   * Creates an instance of IdleTimer\n   * bind all of our internal events here\n   * for best performance\n   * @param {Object} props\n   * @return {IdleTimer}\n   * @private\n   */\n  constructor (props) {\n    super(props)\n\n    /**\n     * Sets initial component state\n     * @type {Object}\n     * @private\n     */\n    this.state = {\n      idle: false,\n      oldDate: +new Date(),\n      lastActive: +new Date(),\n      lastIdle: null,\n      idleTime: 0,\n      remaining: null,\n      pageX: null,\n      pageY: null\n    }\n\n    /**\n     * The timer instance\n     * @type {Timeout}\n     * @private\n     */\n    this.tId = null\n\n    /**\n     * Wether or not events are bound\n     * @type {boolean}\n     * @private\n     */\n    this.eventsBound = false\n\n    // Debounce and throttle can't both be set\n    if (props.debounce > 0 && props.throttle > 0) {\n      throw new Error('onAction can either be throttled or debounced (not both)')\n    }\n\n    // Create debounced action if applicable\n    if (props.debounce > 0) {\n      this._onAction = debounced(props.onAction, props.debounce)\n\n    // Create throttled action if applicable\n    } else if (props.throttle > 0) {\n      this._onAction = throttled(props.onAction, props.throttle)\n\n    // Set custom onAction\n    } else {\n      this._onAction = props.onAction\n    }\n\n    // Create a throttle event handler if applicable\n    if (props.eventsThrottle > 0) {\n      this.handleEvent = throttled(this._handleEvent.bind(this), props.eventsThrottle)\n    } else {\n      this.handleEvent = this._handleEvent.bind(this)\n    }\n\n    // If startOnMount is set, idle state defaults to true\n    if (!props.startOnMount || props.startManually) {\n      this.state.idle = true\n    }\n\n    // Bind all events to component scope, built for speed 🚀\n    this._toggleIdleState = this._toggleIdleState.bind(this)\n    this.start = this.start.bind(this)\n    this.reset = this.reset.bind(this)\n    this.pause = this.pause.bind(this)\n    this.resume = this.resume.bind(this)\n    this.isIdle = this.isIdle.bind(this)\n    this.getRemainingTime = this.getRemainingTime.bind(this)\n    this.getElapsedTime = this.getElapsedTime.bind(this)\n    this.getLastActiveTime = this.getLastActiveTime.bind(this)\n    this.getLastIdleTime = this.getLastIdleTime.bind(this)\n    this.getTotalIdleTime = this.getTotalIdleTime.bind(this)\n    this.getTotalActiveTime = this.getTotalActiveTime.bind(this)\n  }\n\n  /**\n   * Runs once the component has mounted\n   * here we handle automatically starting\n   * the idletimer\n   * @private\n   */\n  componentDidMount () {\n    const { startOnMount, startManually, crossTab, onIdle, onActive } = this.props\n\n    // Set up cross tab\n    /* istanbul ignore next */\n    if (crossTab) {\n      const {\n        type,\n        channelName,\n        fallbackInterval,\n        responseTime,\n        emitOnAllTabs\n      } = Object.assign({\n        channelName: 'idle-timer',\n        fallbackInterval: 2000,\n        responseTime: 100,\n        removeTimeout: 1000 * 60,\n        emitOnAllTabs: false\n      }, crossTab === true ? {} : crossTab)\n\n      this.manager = TabManager({\n        type,\n        channelName,\n        fallbackInterval,\n        responseTime,\n        emitOnAllTabs,\n        onIdle,\n        onActive,\n        start: this.start,\n        reset: this.reset,\n        pause: this.pause,\n        resume: this.resume\n      })\n    }\n\n    if (startManually) return\n    if (startOnMount) {\n      this.start()\n    } else {\n      this._bindEvents()\n    }\n  }\n\n  componentDidUpdate (prevProps) {\n    // Update debounce function\n    if ((prevProps.debounce !== this.props.debounce) && this.props.debounce > 0) {\n      if (this._onAction.cancel) this._onAction.cancel()\n      this._onAction = debounced(this.props.onAction, this.props.debounce)\n    } else\n    // Update throttle function\n    if ((prevProps.throttle !== this.props.throttle) && this.props.throttle > 0) {\n      if (this._onAction.cancel) this._onAction.cancel()\n      this._onAction = throttled(this.props.onAction, this.props.throttle)\n    } else\n    // Remove throttle or debounce\n    if (\n      (prevProps.throttle && this.props.throttle === 0) ||\n      (prevProps.debounce && this.props.debounce === 0)\n    ) {\n      if (this._onAction.cancel) this._onAction.cancel()\n      this._onAction = this.props.onAction\n    }\n\n    // Update event throttle function\n    if (prevProps.eventsThrottle !== this.props.eventsThrottle) {\n      this._unbindEvents()\n      this.handleEvent = throttled(this._handleEvent.bind(this), this.props.eventsThrottle)\n      this._bindEvents()\n    }\n    // Update timeout value\n    if (prevProps.timeout !== this.props.timeout) {\n      if (this.state.idle) this.reset()\n    }\n  }\n\n  /**\n   * Called before the component un-mounts\n   * here we clear the timer and remove\n   * all the event listeners\n   * @private\n   */\n  componentWillUnmount () {\n    // Clear timeout to prevent delayed state changes\n    clearTimeout(this.tId)\n    this._unbindEvents(true)\n    // Cancel any debounced onAction handlers\n    if (this._onAction.cancel) this._onAction.cancel()\n    /* istanbul ignore next */\n    if (this.manager) {\n      this.manager.close().catch(console.error)\n    }\n  }\n\n  /**\n   * Render children if IdleTimer is used as a wrapper\n   * @return {Component} children\n   * @private\n   */\n  render () {\n    const { children } = this.props\n    return children || null\n  }\n\n  /**\n   * Binds the specified events\n   * @private\n   */\n  _bindEvents () {\n    // Don't bind events if\n    // we are not in a browser\n    if (!IS_BROWSER) return\n    // Otherwise we bind all the events\n    // to the supplied element\n    const { element, events, passive, capture } = this.props\n    if (!this.eventsBound) {\n      events.forEach(e => {\n        element.addEventListener(e, this.handleEvent, {\n          capture,\n          passive\n        })\n      })\n      this.eventsBound = true\n    }\n  }\n\n  /**\n   * Unbinds all the bound events\n   * @private\n   */\n  _unbindEvents (force = false) {\n    // If we are not in a browser\n    // we don't need to unbind events\n    if (!IS_BROWSER) return\n    // Unbind all events\n    const { element, events, passive, capture } = this.props\n    if (this.eventsBound || force) {\n      events.forEach(e => {\n        element.removeEventListener(e, this.handleEvent, {\n          capture,\n          passive\n        })\n      })\n      this.eventsBound = false\n    }\n  }\n\n  /**\n   * Toggles the idle state and calls\n   * the correct action function\n   * @private\n   */\n  _toggleIdleState (e) {\n    // Fire the appropriate action\n    // and pass the event through\n    // Toggle the idle state\n    this.setState((prevState) => ({\n      idle: !prevState.idle,\n      lastIdle: !prevState.idle ? (+new Date()) - this.props.timeout : prevState.lastIdle,\n      idleTime: prevState.idle ? prevState.idleTime + (+new Date()) - prevState.lastIdle : prevState.idleTime\n    }), () => {\n      const { onActive, onIdle, stopOnIdle } = this.props\n      const { idle } = this.state\n      if (idle) {\n        if (stopOnIdle) {\n          // Clear any existing timeout\n          clearTimeout(this.tId)\n          this.tId = null\n          // Unbind events\n          this._unbindEvents()\n        }\n\n        if (this.manager) {\n          /* istanbul ignore next */\n          this.manager.idle()\n        } else {\n          onIdle(e)\n        }\n      } else {\n        this._bindEvents()\n        if (this.manager) {\n          /* istanbul ignore next */\n          this.manager.active()\n        } else {\n          onActive(e)\n        }\n      }\n    })\n  }\n\n  /**\n   * Event handler for supported event types\n   * @param  {Object} e event object\n   * @private\n   */\n  _handleEvent (e) {\n    const { remaining, pageX, pageY, idle } = this.state\n    const { timeout, stopOnIdle } = this.props\n\n    // Fire onAction event\n    this._onAction(e)\n\n    // Already active, ignore events\n    if (remaining) return\n\n    // Mousemove event\n    if (e.type === 'mousemove') {\n      // If coords are same, it didn't move\n      /* istanbul ignore next */\n      if (e.pageX === pageX && e.pageY === pageY) {\n        return\n      }\n      // If coords don't exist how could it move\n      if (typeof e.pageX === 'undefined' && typeof e.pageY === 'undefined') {\n        return\n      }\n      // Under 200 ms is hard to do\n      // continuous activity will bypass this\n      /* istanbul ignore next */\n      const elapsed = this.getElapsedTime()\n      /* istanbul ignore next */\n      if (elapsed < 200) {\n        return\n      }\n    }\n\n    // Clear any existing timeout\n    clearTimeout(this.tId)\n    this.tId = null\n\n    // Determine last time User was active, as can't rely on setTimeout ticking at the correct interval\n    const elapsedTimeSinceLastActive = +new Date() - this.getLastActiveTime()\n\n    // If the user is idle or last active time is more than timeout, flip the idle state\n    if ((idle && !stopOnIdle) || (!idle && elapsedTimeSinceLastActive > timeout)) {\n      this._toggleIdleState(e)\n    }\n\n    // Store when the user was last active\n    // and update the mouse coordinates\n    this.setState({\n      lastActive: +new Date(),\n      pageX: e.pageX,\n      pageY: e.pageY\n    })\n\n    // If the user is idle and stopOnIdle flag is not set\n    // set a new timeout\n    if (idle) {\n      if (!stopOnIdle) {\n        this.tId = setTimeout(this._toggleIdleState, timeout)\n      }\n    } else {\n      this.tId = setTimeout(this._toggleIdleState, timeout)\n    }\n  }\n\n  /**\n   * Set initial state and start timer\n   * @name start\n   */\n  start (remote = true) {\n    // Clear timeout\n    clearTimeout(this.tId)\n    this.tId = null\n\n    // Bind the events\n    this._bindEvents()\n\n    // Reset state\n    this.setState({\n      idle: false,\n      oldDate: +new Date(),\n      lastActive: +new Date(),\n      remaining: null\n    })\n\n    if (this.manager) {\n      /* istanbul ignore next */\n      this.manager.setAllIdle(false)\n      /* istanbul ignore next */\n      if (!remote && this.props.crossTab.emitOnAllTabs) {\n        this.manager.send('start')\n      }\n    }\n\n    // Set new timeout\n    const { timeout } = this.props\n    this.tId = setTimeout(this._toggleIdleState, timeout)\n  }\n\n  /**\n   * Restore initial state and restart timer, calling onActive\n   * @name reset\n   */\n  reset (remote = false) {\n    // Clear timeout\n    clearTimeout(this.tId)\n    this.tId = null\n\n    // Bind the events\n    this._bindEvents()\n\n    if (this.state.idle) this.props.onActive()\n\n    if (this.manager) {\n      /* istanbul ignore next */\n      this.manager.setAllIdle(false)\n      /* istanbul ignore next */\n      if (!remote && this.props.crossTab.emitOnAllTabs) {\n        this.manager.send('reset')\n      }\n    }\n\n    // Reset state\n    this.setState({\n      idle: false,\n      oldDate: +new Date(),\n      lastActive: +new Date(),\n      remaining: null\n    })\n\n    // Set new timeout\n    const { timeout } = this.props\n    this.tId = setTimeout(this._toggleIdleState, timeout)\n  }\n\n  /**\n   * Store remaining time and stop timer\n   * @name pause\n   */\n  pause (remote = false) {\n    // Timer is already paused\n    const { remaining } = this.state\n    if (remaining !== null) return\n\n    // Unbind events\n    this._unbindEvents()\n\n    // Clear existing timeout\n    clearTimeout(this.tId)\n    this.tId = null\n\n    // Send event to other tabs\n    if (this.manager) {\n      /* istanbul ignore next */\n      if (!remote && this.props.crossTab.emitOnAllTabs) {\n        this.manager.send('pause')\n      }\n    }\n\n    // Define how much is left on the timer\n    this.setState({\n      remaining: this.getRemainingTime()\n    })\n  }\n\n  /**\n   * Resumes a paused timer\n   * @name resume\n   */\n  resume (remote = false) {\n    // Timer is not paused\n    const { remaining, idle } = this.state\n    if (remaining === null) return\n\n    // Bind events\n    this._bindEvents()\n\n    // Send event to other tabs\n    if (this.manager) {\n      /* istanbul ignore next */\n      if (!remote && this.props.crossTab.emitOnAllTabs) {\n        this.manager.send('resume')\n      }\n    }\n\n    // Start timer and clear remaining\n    // if we are in the active state\n    if (!idle) {\n      // Set a new timeout\n      this.tId = setTimeout(this._toggleIdleState, remaining)\n      // Set new state\n      this.setState({ remaining: null, lastActive: +new Date() })\n    }\n  }\n\n  /**\n   * Time remaining before idle\n   * @name getRemainingTime\n   * @return {number} Milliseconds remaining\n   */\n  getRemainingTime () {\n    const { remaining, lastActive } = this.state\n    const { timeout } = this.props\n\n    // If idle there is no time remaining\n    if (remaining !== null) {\n      return remaining < 0 ? 0 : remaining\n    }\n\n    // Determine remaining, if negative idle didn't finish flipping, just return 0\n    const timeLeft = timeout - ((+new Date()) - lastActive)\n    return timeLeft < 0 ? 0 : timeLeft\n  }\n\n  /**\n   * How much time has elapsed\n   * @name getElapsedTime\n   * @return {Timestamp}\n   */\n  getElapsedTime () {\n    const { oldDate } = this.state\n    return (+new Date()) - oldDate\n  }\n\n  /**\n   * Last time the user was idle\n   * @name getLastIdleTime\n   * @return {Timestamp}\n   */\n  getLastIdleTime () {\n    const { lastIdle } = this.state\n    return lastIdle\n  }\n\n  /**\n   * Total time the user was idle\n   * @name getTotalIdleTime\n   * @return {number}\n   */\n  getTotalIdleTime () {\n    const { idle, lastIdle, idleTime } = this.state\n    if (idle) {\n      return ((+new Date()) - lastIdle) + idleTime\n    } else {\n      return idleTime\n    }\n  }\n\n  /**\n   * Last time the user was active\n   * @name getLastActiveTime\n   * @return {Timestamp}\n   */\n  getLastActiveTime () {\n    const { lastActive } = this.state\n    return lastActive\n  }\n\n  /**\n   * Total time the user was active\n   * @name getTotalActiveTime\n   * @return {number}\n   */\n  getTotalActiveTime () {\n    return this.getElapsedTime() - this.getTotalIdleTime()\n  }\n\n  /**\n   * Returns wether or not the user is idle\n   * @name isIdle\n   * @return {boolean}\n   */\n  isIdle () {\n    const { idle } = this.state\n    return idle\n  }\n\n  /**\n   * Returns wether or not this is the leader tab\n   * @name isLeader\n   * @return {boolean}\n   */\n  isLeader () {\n    return this.manager ? this.manager.isLeader() : true\n  }\n}\n\n/**\n * Type checks for every property\n * @type {Object}\n * @private\n */\nIdleTimer.propTypes = {\n  /**\n   * Activity Timeout in milliseconds\n   * default: 1200000\n   * @type {Number}\n   */\n  timeout: PropTypes.number,\n  /**\n   * DOM events to listen to\n   * default: see [default events](https://github.com/SupremeTechnopriest/react-idle-timer#default-events)\n   * @type {Array}\n   */\n  events: PropTypes.arrayOf(PropTypes.string),\n  /**\n   * Function to call when user is idle\n   * default: () => {}\n   * @type {Function}\n   */\n  onIdle: PropTypes.func,\n  /**\n   * Function to call when user becomes active\n   * default: () => {}\n   * @type {Function}\n   */\n  onActive: PropTypes.func,\n  /**\n   * Function to call on user actions\n   * default: () => {}\n   * @type {Function}\n   */\n  onAction: PropTypes.func,\n  /**\n   * Debounce the onAction function by setting delay in milliseconds\n   * default: 0\n   * @type {Number}\n   */\n  debounce: PropTypes.number,\n  /**\n   * Throttle the onAction function by setting delay in milliseconds\n   * default: 0\n   * @type {Number}\n   */\n  throttle: PropTypes.number,\n  /**\n   * Throttle the event handler function by setting delay in milliseconds\n   * default: 200\n   * @type {Number}\n   */\n  eventsThrottle: PropTypes.number,\n  /**\n   * Element reference to bind activity listeners to\n   * default: document\n   * @type {Object}\n   */\n  element: PropTypes.oneOfType([PropTypes.object, PropTypes.element]),\n  /**\n   * Start the timer on mount\n   * default: true\n   * @type {Boolean}\n   */\n  startOnMount: PropTypes.bool,\n  /**\n   * Require the timer to be started manually.\n   * default: false\n   * @type {Boolean}\n   */\n  startManually: PropTypes.bool,\n  /**\n   * Once the user goes idle the IdleTimer will not\n   * reset on user input instead, reset() must be\n   * called manually to restart the timer\n   * default: false\n   * @type {Boolean}\n   */\n  stopOnIdle: PropTypes.bool,\n  /**\n   * Bind events passively\n   * default: true\n   * @type {Boolean}\n   */\n  passive: PropTypes.bool,\n  /**\n   * Capture events\n   * default: true\n   * @type {Boolean}\n   */\n  capture: PropTypes.bool,\n  /**\n   * Cross Tab functionality.\n   * default: false\n   * @type {Boolean|Object}\n   */\n  crossTab: PropTypes.oneOfType([\n    PropTypes.bool,\n    PropTypes.shape({\n      type: PropTypes.oneOf(['broadcastChannel', 'localStorage', 'simulate']),\n      channelName: PropTypes.string,\n      fallbackInterval: PropTypes.number,\n      responseTime: PropTypes.number,\n      removeTimeout: PropTypes.number,\n      emitOnAllTabs: PropTypes.bool\n    })\n  ])\n}\n\n/**\n * Sets default property values\n * @type {Object}\n * @private\n */\nIdleTimer.defaultProps = {\n  timeout: 1000 * 60 * 20,\n  element: DEFAULT_ELEMENT,\n  events: DEFAULT_EVENTS,\n  onIdle: () => { },\n  onActive: () => { },\n  onAction: () => { },\n  debounce: 0,\n  throttle: 0,\n  eventsThrottle: 200,\n  startOnMount: true,\n  startManually: false,\n  stopOnIdle: false,\n  capture: true,\n  passive: true,\n  crossTab: false\n}\n\nexport default IdleTimer\n","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","/**\n *  ___    _ _     _____ _\n * |_ _|__| | | __|_   _(_)_ __ ___   ___ _ __\n *  | |/ _` | |/ _ \\| | | | '_ ` _ \\ / _ \\ '__|\n *  | | (_| | |  __/| | | | | | | | |  __/ |\n * |___\\__,_|_|\\___||_| |_|_| |_| |_|\\___|_|\n *\n * @name useIdleTimer\n * @author Randy Lebeau\n * @private\n */\n\nimport { useEffect, useRef, useMemo } from 'react'\nimport PropTypes from 'prop-types'\nimport { TabManager } from './TabManager'\nimport { IS_BROWSER, DEFAULT_ELEMENT, DEFAULT_EVENTS, debounced, throttled } from './utils'\n\n/**\n * Detects when your user is idle\n * @function useIdleTimer\n * @private\n */\nfunction useIdleTimer ({\n  timeout = 1000 * 60 * 20,\n  element = DEFAULT_ELEMENT,\n  events = DEFAULT_EVENTS,\n  onIdle = () => { },\n  onActive = () => { },\n  onAction = () => { },\n  debounce = 0,\n  throttle = 0,\n  eventsThrottle = 200,\n  startOnMount = true,\n  startManually = false,\n  stopOnIdle = false,\n  capture = true,\n  passive = true,\n  crossTab = false\n} = {}) {\n  const eventsBound = useRef(false)\n  const idle = useRef(true)\n  const oldDate = useRef(+new Date())\n  const remaining = useRef(null)\n  const pageX = useRef(null)\n  const pageY = useRef(null)\n  const tId = useRef(null)\n  const lastActive = useRef(null)\n  const lastIdle = useRef(null)\n  const idleTime = useRef(0)\n  const firstLoad = useRef(true)\n  const _timeout = useRef(timeout)\n  const manager = useRef(null)\n\n  /* istanbul ignore next */\n  if (crossTab) {\n    if (crossTab === true) crossTab = {}\n    crossTab = Object.assign({\n      channelName: 'idle-timer',\n      fallbackInterval: 2000,\n      responseTime: 100,\n      removeTimeout: 1000 * 60,\n      emitOnAllTabs: false\n    }, crossTab)\n  }\n\n  // Event emitters\n  const emitOnIdle = useRef(onIdle)\n  const emitOnActive = useRef(onActive)\n  const emitOnAction = useRef(onAction)\n\n  useEffect(() => {\n    emitOnIdle.current = onIdle\n  }, [onIdle])\n\n  useEffect(() => {\n    emitOnActive.current = onActive\n  }, [onActive])\n\n  useEffect(() => {\n    emitOnAction.current = onAction\n  }, [onAction])\n\n  const intermediateOnAction = useMemo(() => {\n    function callOnAction (e) {\n      emitOnAction.current(e)\n    }\n\n    // Cancel any existing debounce timeouts\n    if (callOnAction.cancel) callOnAction.cancel()\n\n    // Create debounced action if applicable\n    if (debounce > 0) {\n      return debounced(callOnAction, debounce)\n\n      // Create throttled action if applicable\n    } else if (throttle > 0) {\n      return throttled(callOnAction, throttle)\n\n      // No throttle or debounce\n    } else {\n      return callOnAction\n    }\n  }, [throttle, debounce])\n\n  /**\n   * Toggles the idle state and calls\n   * the correct action function\n   * @private\n   */\n  const _toggleIdleState = e => {\n    const nextIdle = !idle.current\n    idle.current = nextIdle\n    if (nextIdle) {\n      if (stopOnIdle) {\n        // Clear any existing timeout\n        clearTimeout(tId.current)\n        tId.current = null\n        // Unbind events\n        _unbindEvents()\n      }\n      lastIdle.current = (+new Date()) - _timeout.current\n      if (manager.current) {\n        /* istanbul ignore next */\n        manager.current.idle()\n      } else {\n        emitOnIdle.current(e)\n      }\n    } else {\n      idleTime.current += (+new Date()) - lastIdle.current\n      _bindEvents()\n      if (manager.current) {\n        /* istanbul ignore next */\n        manager.current.active()\n      } else {\n        emitOnActive.current(e)\n      }\n    }\n  }\n\n  /**\n   * Event handler\n   * @param {Event} e\n   */\n  const _handleEvent = e => {\n    // Fire onAction event\n    intermediateOnAction(e)\n\n    // Already active, ignore events\n    if (remaining.current) return\n\n    // Mousemove event\n    /* istanbul ignore next */\n    if (e.type === 'mousemove') {\n      // If coords are same, it didn't move\n      if (e.pageX === pageX && e.pageY === pageY) {\n        return\n      }\n      // If coords don't exist how could it move\n      if (typeof e.pageX === 'undefined' && typeof e.pageY === 'undefined') {\n        return\n      }\n      // Under 200 ms is hard to do\n      // continuous activity will bypass this\n      const elapsed = getElapsedTime()\n      if (elapsed < 200) {\n        return\n      }\n    }\n\n    // Clear any existing timeout\n    clearTimeout(tId.current)\n    tId.current = null\n\n    // Determine last time User was active, as can't rely on setTimeout ticking at the correct interval\n    const elapsedTimeSinceLastActive = +new Date() - getLastActiveTime()\n\n    // If the user is idle or last active time is more than timeout, flip the idle state\n    if (\n      (idle.current && !stopOnIdle) ||\n      (!idle.current && elapsedTimeSinceLastActive > _timeout.current)\n    ) {\n      _toggleIdleState(e)\n    }\n\n    // Store when the user was last active\n    // and update the mouse coordinates\n    lastActive.current = +new Date()\n    pageX.current = e.pageX\n    pageY.current = e.pageY\n\n    // If the user is active, set a new timeout\n    if (!idle.current) {\n      tId.current = setTimeout(_toggleIdleState, _timeout.current)\n    }\n  }\n\n  /**\n   * Reference to current handleEvent function.\n   * @private\n   */\n  const handleEvent = useRef(_handleEvent)\n\n  /**\n   * Binds the specified events\n   * @private\n   */\n  const _bindEvents = () => {\n    // Don't bind events if\n    // we are not in a browser\n    if (!IS_BROWSER) return\n    // Otherwise we bind all the events\n    // to the supplied element\n    if (!eventsBound.current) {\n      events.forEach(e => {\n        element.addEventListener(e, handleEvent.current, {\n          capture,\n          passive\n        })\n      })\n      eventsBound.current = true\n    }\n  }\n\n  /**\n   * Unbinds all the bound events\n   * @private\n   */\n  const _unbindEvents = (force = false) => {\n    // If we are not in a browser\n    // we don't need to unbind events\n    if (!IS_BROWSER) return\n    // Unbind all events\n    if (eventsBound.current || force) {\n      events.forEach(e => {\n        element.removeEventListener(e, handleEvent.current, {\n          capture,\n          passive\n        })\n      })\n      eventsBound.current = false\n    }\n  }\n\n  /**\n   * Time remaining before idle\n   * @name getRemainingTime\n   * @return {number} Milliseconds remaining\n   */\n  const getRemainingTime = () => {\n    // If idle there is no time remaining\n    if (remaining.current !== null) {\n      return remaining.current < 0 ? 0 : remaining.current\n    }\n\n    // Determine remaining, if negative idle didn't finish flipping, just return 0\n    const timeLeft = _timeout.current - ((+new Date()) - lastActive.current)\n    return timeLeft < 0 ? 0 : timeLeft\n  }\n\n  /**\n   * How much time has elapsed\n   * @name getElapsedTime\n   * @return {Timestamp}\n   */\n  const getElapsedTime = () => (+new Date()) - oldDate.current\n\n  /**\n   * Last time the user was idle\n   * @name getLastIdleTime\n   * @return {Timestamp}\n   */\n  const getLastIdleTime = () => lastIdle.current\n\n  /**\n   * Get the total time user is idle\n   * @name getTotalIdleTime\n   * @return {number} Milliseconds idle\n   */\n  const getTotalIdleTime = () => {\n    if (idle.current) {\n      return ((+new Date()) - lastIdle.current) + idleTime.current\n    } else {\n      return idleTime.current\n    }\n  }\n\n  /**\n   * Last time the user was active\n   * @name getLastActiveTime\n   * @return {Timestamp}\n   */\n  const getLastActiveTime = () => lastActive.current\n\n  /**\n   * Get the total time user is active\n   * @name getTotalActiveTime\n   * @return {number} Milliseconds active\n   */\n  const getTotalActiveTime = () => getElapsedTime() - getTotalIdleTime()\n\n  /**\n   * Returns wether or not the user is idle\n   * @name isIdle\n   * @return {Boolean}\n   */\n  const isIdle = () => idle.current\n\n  /**\n   * Returns wether or not this is the leader tab\n   * @returns {Boolean}\n   */\n  const isLeader = () => manager.current ? manager.current.isLeader() : true\n\n  /**\n  * Set initial state and start timer\n  * @name reset\n  */\n  const start = (remote = false) => {\n    // Clear timeout\n    clearTimeout(tId.current)\n    tId.current = null\n\n    // Bind the events\n    _bindEvents()\n\n    // Set state\n    idle.current = false\n    oldDate.current = +new Date()\n    lastActive.current = +new Date()\n    remaining.current = null\n\n    if (manager.current) {\n      /* istanbul ignore next */\n      manager.current.setAllIdle(false)\n      /* istanbul ignore next */\n      if (!remote && crossTab.emitOnAllTabs) {\n        manager.current.send('start')\n      }\n    }\n\n    // Set new timeout\n    tId.current = setTimeout(_toggleIdleState, _timeout.current)\n  }\n\n  /**\n  * Restore initial state and restart timer, calling onActive\n  * @name reset\n  */\n  const reset = (remote = false) => {\n    // Clear timeout\n    clearTimeout(tId.current)\n    tId.current = null\n\n    // Bind the events\n    _bindEvents()\n\n    if (idle.current) emitOnActive.current()\n\n    // Reset state\n    idle.current = false\n    oldDate.current = +new Date()\n    lastActive.current = +new Date()\n    remaining.current = null\n\n    if (manager.current) {\n      /* istanbul ignore next */\n      manager.current.setAllIdle(false)\n      /* istanbul ignore next */\n      if (!remote && crossTab.emitOnAllTabs) {\n        manager.current.send('reset')\n      }\n    }\n\n    // Set new timeout\n    tId.current = setTimeout(_toggleIdleState, _timeout.current)\n  }\n\n  /**\n   * Store remaining time and stop timer\n   * @name pause\n   */\n  const pause = (remote = false) => {\n    // Timer is already paused\n    if (remaining.current !== null) return\n\n    // Unbind events\n    _unbindEvents()\n\n    // Clear existing timeout\n    clearTimeout(tId.current)\n    tId.current = null\n\n    // Define how much is left on the timer\n    remaining.current = getRemainingTime()\n\n    if (manager.current) {\n      /* istanbul ignore next */\n      if (!remote && crossTab.emitOnAllTabs) {\n        manager.current.send('pause')\n      }\n    }\n  }\n\n  /**\n   * Resumes a paused timer\n   * @name resume\n   */\n  const resume = (remote = false) => {\n    // Timer is not paused\n    if (remaining.current === null) return\n\n    // Bind events\n    _bindEvents()\n\n    // Start timer and clear remaining\n    // if we are in the idle state\n    if (!idle.current) {\n      // Set a new timeout\n      tId.current = setTimeout(_toggleIdleState, remaining.current)\n      // Set states\n      remaining.current = null\n      lastActive.current = +new Date()\n    }\n\n    if (manager.current) {\n      /* istanbul ignore next */\n      if (!remote && crossTab.emitOnAllTabs) {\n        manager.current.send('resume')\n      }\n    }\n  }\n\n  /**\n   * Hook lifecycle\n   */\n  useEffect(() => {\n    // Debounce and throttle can't both be set\n    if (debounce > 0 && throttle > 0) {\n      throw new Error('onAction can either be throttled or debounced (not both)')\n    }\n\n    // Set up cross tab\n    /* istanbul ignore next */\n    if (crossTab) {\n      manager.current = TabManager({\n        type: crossTab.type,\n        channelName: crossTab.channelName,\n        fallbackInterval: crossTab.fallbackInterval,\n        responseTime: crossTab.responseTime,\n        emitOnAllTabs: crossTab.emitOnAllTabs,\n        onIdle: emitOnIdle.current,\n        onActive: emitOnActive.current,\n        start,\n        reset,\n        pause,\n        resume\n      })\n    }\n\n    // If startOnMount is enabled, start the timer\n    if (startManually) {\n      return async () => {\n        clearTimeout(tId.current)\n        _unbindEvents(true)\n        if (crossTab) await manager.current.close()\n      }\n    }\n\n    if (startOnMount) {\n      start()\n    } else {\n      _bindEvents()\n    }\n\n    // Clear and unbind on unmount\n    return async () => {\n      clearTimeout(tId.current)\n      _unbindEvents(true)\n      if (intermediateOnAction.cancel) intermediateOnAction.cancel()\n      if (crossTab) await manager.current.close()\n    }\n  }, [])\n\n  useEffect(() => {\n    const eventsWereBound = eventsBound.current\n    if (eventsWereBound) _unbindEvents()\n    if (eventsThrottle > 0) {\n      handleEvent.current = throttled(_handleEvent, eventsThrottle)\n    } else {\n      handleEvent.current = _handleEvent\n    }\n    if (eventsWereBound) _bindEvents()\n  }, [eventsThrottle])\n\n  useEffect(() => {\n    _timeout.current = timeout\n    if (!firstLoad.current && idle.current) {\n      reset()\n    }\n    firstLoad.current = false\n  }, [timeout])\n\n  return {\n    isIdle,\n    isLeader,\n    start,\n    pause,\n    reset,\n    resume,\n    getLastIdleTime,\n    getTotalIdleTime,\n    getLastActiveTime,\n    getTotalActiveTime,\n    getElapsedTime,\n    getRemainingTime\n  }\n}\n\n/**\n * Type checks for every property\n * @type {Object}\n * @private\n */\nuseIdleTimer.propTypes = {\n  /**\n   * Activity Timeout in milliseconds\n   * default: 1200000\n   * @type {number}\n   */\n  timeout: PropTypes.number,\n  /**\n   * DOM events to listen to\n   * default: see [default events](https://github.com/SupremeTechnopriest/react-idle-timer#default-events)\n   * @type {Array}\n   */\n  events: PropTypes.arrayOf(PropTypes.string),\n  /**\n   * Function to call when user is idle.\n   * default: () => {}\n   * @type {Function}\n   */\n  onIdle: PropTypes.func,\n  /**\n   * Function to call when user becomes active.\n   * default: () => {}\n   * @type {Function}\n   */\n  onActive: PropTypes.func,\n  /**\n   * Function to call on user actions.\n   * default: () => {}\n   * @type {Function}\n   */\n  onAction: PropTypes.func,\n  /**\n   * Debounce the onAction function by setting delay in milliseconds.\n   * default: 0\n   * @type {number}\n   */\n  debounce: PropTypes.number,\n  /**\n   * Throttle the onAction function by setting delay in milliseconds.\n   * default: 0\n   * @type {number}\n   */\n  throttle: PropTypes.number,\n  /**\n   * Throttle the event handler function by setting delay in milliseconds.\n   * default: 200\n   * @type {number}\n   */\n  eventsThrottle: PropTypes.number,\n  /**\n   * Element reference to bind activity listeners to.\n   * default: document\n   * @type {Object}\n   */\n  element: PropTypes.oneOfType([PropTypes.object, PropTypes.element]),\n  /**\n   * Start the timer on mount.\n   * default: true\n   * @type {Boolean}\n   */\n  startOnMount: PropTypes.bool,\n  /**\n   * Require the timer to be started manually.\n   * default: false\n   * @type {Boolean}\n   */\n  startManually: PropTypes.bool,\n  /**\n   * Once the user goes idle the IdleTimer will not\n   * reset on user input instead, start() or reset() must be\n   * called manually to restart the timer.\n   * default: false\n   * @type {Boolean}\n   */\n  stopOnIdle: PropTypes.bool,\n  /**\n   * Bind events passively.\n   * default: true\n   * @type {Boolean}\n   */\n  passive: PropTypes.bool,\n  /**\n   * Capture events.\n   * default: true\n   * @type {Boolean}\n   */\n  capture: PropTypes.bool,\n  /**\n   * Cross Tab functionality.\n   * default: false\n   * @type {Boolean|Object}\n   */\n  crossTab: PropTypes.oneOfType([\n    PropTypes.bool,\n    PropTypes.shape({\n      type: PropTypes.oneOf(['broadcastChannel', 'localStorage', 'simulate']),\n      channelName: PropTypes.string,\n      fallbackInterval: PropTypes.number,\n      responseTime: PropTypes.number,\n      removeTimeout: PropTypes.number,\n      emitOnAllTabs: PropTypes.bool\n    })\n  ])\n}\n\n/**\n * Sets default property values\n * @type {Object}\n * @private\n */\nuseIdleTimer.defaultProps = {\n  timeout: 1000 * 60 * 20,\n  element: DEFAULT_ELEMENT,\n  events: DEFAULT_EVENTS,\n  onIdle: () => { },\n  onActive: () => { },\n  onAction: () => { },\n  debounce: 0,\n  throttle: 0,\n  eventsThrottle: 200,\n  startOnMount: true,\n  startManually: false,\n  stopOnIdle: false,\n  capture: true,\n  passive: true,\n  crossTab: false\n}\n\nexport default useIdleTimer\n"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","_assertThisInitialized","self","ReferenceError","_setPrototypeOf","o","p","setPrototypeOf","__proto__","_typeof","obj","Symbol","iterator","constructor","_possibleConstructorReturn","call","assertThisInitialized","_getPrototypeOf","getPrototypeOf","asyncGeneratorStep","gen","resolve","reject","_next","_throw","arg","info","value","error","done","Promise","then","_asyncToGenerator","fn","this","args","arguments","apply","err","undefined","_arrayLikeToArray","arr","len","arr2","Array","_slicedToArray","isArray","arrayWithHoles","_arr","_n","_d","_e","_s","_i","next","push","iterableToArrayLimit","minLen","arrayLikeToArray","n","toString","slice","name","from","test","unsupportedIterableToArray","nonIterableRest","runtime","exports","Op","hasOwn","hasOwnProperty","$Symbol","iteratorSymbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","wrap","innerFn","outerFn","tryLocsList","protoGenerator","Generator","generator","create","context","Context","_invoke","state","GenStateSuspendedStart","method","GenStateExecuting","Error","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","GenStateSuspendedYield","makeInvokeMethod","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","invoke","result","__await","unwrapped","previousPromise","callInvokeWithMethodAndArg","resultName","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","displayName","isGeneratorFunction","genFun","ctor","mark","awrap","async","iter","keys","object","reverse","pop","skipTempReset","prev","charAt","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","Function","IS_BROWSER","window","DEFAULT_ELEMENT","document","DEFAULT_EVENTS","debounced","delay","timerId","clearTimeout","setTimeout","cancel","throttled","lastCall","now","Date","getTime","lastMs","additional","microSeconds","ms","randomToken","Math","random","substring","sleep","time","channelName","messagesCallback","bc","BroadcastChannel","onmessage","msg","data","close","channelState","onMessage","postMessage","messageJson","canBeUsed","averageResponseTime","ObliviousSet","ttl","set","Set","timeMap","Map","has","add","_removeTooOldValues","clear","olderThen","get","getLocalStorage","localStorage","e","addStorageEventListener","listener","ev","JSON","parse","newValue","addEventListener","ls","setItem","removeItem","options","uuid","eMIs","removeTimeout","msgObj","token","messagesCallbackTime","removeEventListener","writeObj","stringify","createEvent","initEvent","dispatchEvent","userAgent","navigator","toLowerCase","includes","defaultTime","SIMULATE_CHANNELS","filter","channel","METHODS","BroadcastChannelMethod","LocalStorageMethod","chooseMethod","SimulateMethod","find","m","useMethod","map","MessageChannel","closed","_isListening","_onMessageListener","_addEventListeners","message","internal","_unSendMessagePromises","_beforeClose","_preparePromises","_prepareChannel","_post","listenObj","_removeListenerObject","_addListenerObject","awaitPrepare","all","_this","_state","messageChannel","sendPromise","maybePromise","s","_hasMessageListeners","listenerFn","_startListening","_stopListening","LeaderElection","_channel","_options","isLeader","isDead","_isApplying","_reApply","_unloadFns","_listeners","_intervals","_duplicateListeners","_duplicateCalled","_onBeforeDie","unloadFn","die","stopCriteria","handleMessage","_this2","action","_sendMessage","responseTime","leaderElector","isLeaderListener","beLeader","success","applyOnce","_awaitLeadershipPromise","resolved","clearInterval","interval","whenDeathListener","setInterval","fallbackInterval","onBeforeDie","_this3","uFn","msgJson","postInternal","TabManager","emitOnAllTabs","onIdle","onActive","start","pause","resume","elector","_leaderElector","createLeaderElection","registry","leader","allIdle","awaitLeadership","id","idle","active","isIdle","every","v","send","isActive","some","onDuplicate","isAllIdle","setAllIdle","bool","IdleTimer","subClass","superClass","Component","oldDate","lastActive","lastIdle","idleTime","remaining","pageX","pageY","tId","eventsBound","debounce","throttle","_onAction","onAction","eventsThrottle","handleEvent","_handleEvent","bind","startOnMount","startManually","_toggleIdleState","getRemainingTime","getElapsedTime","getLastActiveTime","getLastIdleTime","getTotalIdleTime","getTotalActiveTime","crossTab","assign","manager","_bindEvents","prevProps","_unbindEvents","timeout","console","children","element","events","passive","capture","force","setState","prevState","_this4","stopOnIdle","elapsedTimeSinceLastActive","remote","timeLeft","useIdleTimer","useRef","firstLoad","_timeout","emitOnIdle","emitOnActive","emitOnAction","useEffect","current","intermediateOnAction","useMemo","callOnAction","nextIdle","eventsWereBound","propTypes","PropTypes","number","arrayOf","string","func","oneOfType","shape","oneOf","defaultProps"],"mappings":"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"}